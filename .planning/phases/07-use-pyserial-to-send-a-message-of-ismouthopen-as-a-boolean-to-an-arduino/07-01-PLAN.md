---
phase: 07-use-pyserial-to-send-a-message-of-ismouthopen-as-a-boolean-to-an-arduino
plan: 01
type: execute
---

<objective>
Send mouth open state as boolean to Arduino via serial communication.

Purpose: Enable Arduino to receive real-time mouth state data for external hardware control (LEDs, motors, etc.)
Output: Working serial communication sending '1' (open) or '0' (closed) to Arduino
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-mouth-detection-logic/03-01-SUMMARY.md
@.planning/phases/06-normalized-mouth-center-coordinates/06-01-SUMMARY.md
@main.py
@requirements.txt

**Current state:**
- Mouth state detection working with `mouth_state` variable ("OPEN" or "CLOSED")
- Detection based on 20px threshold between landmarks 13 and 14
- Real-time processing at ~30fps

**Serial communication requirements:**
- Send boolean representation: '1' for OPEN, '0' for CLOSED
- Use pyserial library (standard Python serial communication)
- Handle common serial port names (e.g., /dev/ttyUSB0, /dev/ttyACM0 on Linux/Mac, COM3 on Windows)
- Graceful error handling if Arduino not connected
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pyserial dependency and initialize serial connection</name>
  <files>requirements.txt, main.py</files>
  <action>
Add pyserial to requirements.txt. In main.py, import serial at top. Add SERIAL_PORT and BAUD_RATE constants (default: '/dev/ttyUSB0' and 9600). In main() function before the video capture loop, attempt to initialize serial connection with try/except block. If connection fails, print warning but continue running (serial is optional feature). Store serial connection object in variable for use in loop. Use timeout=1 to prevent blocking.

Error handling: Catch serial.SerialException and print helpful message listing common port names to try. Don't crash if Arduino not connected - just disable serial output.
  </action>
  <verify>Code runs without crashing when Arduino is not connected. Serial connection object created when Arduino is connected.</verify>
  <done>requirements.txt contains pyserial. main.py imports serial, defines constants, attempts connection with graceful error handling.</done>
</task>

<task type="auto">
  <name>Task 2: Send mouth state as boolean over serial</name>
  <files>main.py</files>
  <action>
Inside the main loop, after mouth_state is determined (line ~113), check if serial connection is active. If active, convert mouth_state to boolean byte: send b'1' if mouth_state == "OPEN", else send b'0'. Use ser.write() method. Send newline character b'\n' after each state for Arduino's Serial.readStringUntil('\n') compatibility. Wrap in try/except to catch write errors (cable disconnected, etc.) - if error occurs, print warning and set serial connection to None to stop further attempts.

Keep serial sending fast to maintain real-time performance - write() should be non-blocking with timeout already set.
  </action>
  <verify>When mouth opens/closes, serial data is sent (verify with ser.write() call in code). Error handling catches disconnection gracefully.</verify>
  <done>Serial data sent every frame with mouth state. b'1\n' for OPEN, b'0\n' for CLOSED. Graceful error handling for disconnection.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Serial communication sending mouth state ('1' or '0') to Arduino</what-built>
  <how-to-verify>
    1. Upload a simple Arduino sketch that reads serial and blinks LED based on state:
       ```
       void setup() {
         Serial.begin(9600);
         pinMode(LED_BUILTIN, OUTPUT);
       }
       void loop() {
         if (Serial.available() > 0) {
           char state = Serial.read();
           digitalWrite(LED_BUILTIN, state == '1' ? HIGH : LOW);
         }
       }
       ```
    2. Connect Arduino via USB
    3. Update SERIAL_PORT constant in main.py if needed (check Arduino IDE Tools > Port)
    4. Run: python main.py
    5. Open and close your mouth
    6. Confirm: Arduino LED turns on when mouth opens, off when mouth closes
    7. Test: Disconnect Arduino cable while running - program should continue with warning message
  </how-to-verify>
  <resume-signal>Type "approved" if LED responds to mouth state, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] pyserial added to requirements.txt
- [ ] Serial connection initialized with error handling
- [ ] Mouth state sent as '1' or '0' over serial
- [ ] Code continues running if Arduino not connected
- [ ] Arduino responds to mouth state changes (human verified)
</verification>

<success_criteria>

- All tasks completed
- pyserial integrated into main.py
- Serial communication sends boolean state in real-time
- Graceful degradation when Arduino not connected
- Arduino hardware responds to mouth state (LED or other output)
- Phase 7 complete
</success_criteria>

<output>
After completion, create `.planning/phases/07-use-pyserial-to-send-a-message-of-ismouthopen-as-a-boolean-to-an-arduino/07-01-SUMMARY.md`:

# Phase 7 Plan 1: Arduino Serial Communication Summary

**[One-liner describing what was accomplished]**

## Accomplishments

- pyserial dependency added
- Serial connection with graceful error handling
- Real-time mouth state transmission to Arduino
- Optional serial feature - code runs with or without Arduino

## Files Created/Modified

- `requirements.txt` - Added pyserial
- `main.py` - Added serial communication with error handling

## Decisions Made

[Serial port configuration, baud rate, data format decisions]

## Issues Encountered

[Any serial communication issues, port detection problems, or hardware compatibility notes]

## Next Phase Readiness

Phase 7 complete. Arduino integration functional. System ready for deployment or further hardware integration.
</output>
